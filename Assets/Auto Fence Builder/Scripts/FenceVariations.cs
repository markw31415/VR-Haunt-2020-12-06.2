using System.Collections;using System.Collections.Generic;using UnityEngine;// Used to hold info about each step in a variation sequence// Although this is similar to the FenceVariant class, it's conceptually easier to  remember them as // two different entities, and can be tweaked to their different needs // (FenceVariant has a small fixed number of choices, SeqVariant is often a longer dynamic list)[System.Serializable]public class SeqVariant{    public bool variantEnabled; // is it enabled in the variants List    public int objIndex;    public bool invert, backToFront, mirrorZ;    public Vector3 pos, size = Vector3.one, rot;    public float   probability;    public GameObject go;    public bool stepEnabled = true;    public SeqVariant()    {        Init();    }    public void Init()    {        invert = false; backToFront = false; mirrorZ = false;        objIndex = 0;        pos = Vector3.zero; size = Vector3.one; rot = Vector3.zero;        variantEnabled = true;        probability = 1;        go = null;        stepEnabled = true;    }    // Initialize and set to first object in Variants List    public void InitWithBaseVariant(List<FenceVariant> variantList)    {        Init();        objIndex = 0;        go = variantList[0].go;    }    public SeqVariant(int objectIndex)    {        Init();        objIndex = objectIndex;    }    public SeqVariant(int objectIndex, FenceVariant variant)    {        Init();        objIndex = objectIndex;        go = variant.go;        if(go == null)            Debug.LogWarning("SeqVariant(int objectIndex, FenceVariant variant):  variant.go is null");        pos = variant.positionOffset;        size = variant.size;        rot = variant.rotation;    }    public SeqVariant(GameObject inGO)    {        Init();        go = inGO;        Debug.LogWarning("No Object Index for GO");    }    public SeqVariant(SeqVariant inSeq)    {        stepEnabled = inSeq.stepEnabled;        invert = inSeq.invert;        backToFront = inSeq.backToFront;        mirrorZ = inSeq.mirrorZ;        pos = inSeq.pos;        size = inSeq.size;        rot = inSeq.rot;        objIndex = inSeq.objIndex;        variantEnabled = inSeq.variantEnabled;        probability = inSeq.probability;        go = inSeq.go;    }    public SeqVariant(GameObject inGO, bool inv, bool x, bool z, int index, Vector3 p, Vector3 s, Vector3 r, float prob, bool enable)    {        invert = inv; backToFront = x; mirrorZ = z;        objIndex = index;        pos = p; size = s; rot = r;        variantEnabled = enable;        probability = prob;        go = inGO;        if(size.x == 0)            Debug.Log("SeqVariant size 0");    }    public static SeqVariant[] CreateSeqVariantArray(int size)    {        SeqVariant[] array = new SeqVariant[size];        for (int i = 0; i < size; i++)        {            array[i] = new SeqVariant();        }        return array;    }    public static List<SeqVariant> CreateInitialisedSeqVariantList(int size)    {        if (size < 2)        {            //Debug.LogWarning("Requested Sequencet Length = 0");            size = 2; // For now, ensure there's always a minimum seq length of 2 steps.        }        SeqVariant[] newVariants = CreateSeqVariantArray(size); //legacy, redundant, remove in next update        List<SeqVariant> variantList = new List<SeqVariant>(newVariants);        return variantList;    }    //------------------------------------------------    public static int[] GetShuffledIndexArray(int length, int loopLength, AutoFenceCreator.LayerSet layer)    {        int[] shuffledIndexList = new int[length];        RandomLookupAFWB rTable = RandomLookupAFWB.randForRailA;        int rIndex = RandomLookupAFWB.railARandLookupIndex;        if (layer == AutoFenceCreator.LayerSet.railBLayerSet)        {            rTable = RandomLookupAFWB.randForRailA;            rIndex = RandomLookupAFWB.railARandLookupIndex;        }        else if (layer == AutoFenceCreator.LayerSet.postLayerSet)        {            rTable = RandomLookupAFWB.randForPost;            rIndex = RandomLookupAFWB.postRandLookupIndex;        }        if(rTable == null)        {            Debug.LogWarning("Missing Table for " + layer);            return shuffledIndexList;        }        int loopIndex = 0;        for (int i = 0; i < length; i++)        {            shuffledIndexList[i] = loopIndex++;            if (loopIndex == loopLength)                loopIndex = 0;        }        // Now shuffle them        for (int i = 0; i < length; i++)        {            //int j = UnityEngine.Random.Range(i, length); //numFenceSections is exclusive because  Random.Range(int, int)            int j = rTable.RandomRange(i, length);            rIndex++;            int t = shuffledIndexList[j];            shuffledIndexList[j] = shuffledIndexList[i];            shuffledIndexList[i] = t;        }        return shuffledIndexList;    }    //------------------------------------------------    public static void ShuffleObjectIndicesInSequence(List<SeqVariant> sequence, int numSteps, List<FenceVariant> variantsList, bool shuffleStepSettingsAlso,                                                        AutoFenceCreator.LayerSet layer)    {        //AssignObjectIndicesInSequence(sequence, numSteps, variantsList);        int numVariants = variantsList.Count;        int seqLength = sequence.Count;        int[] shuffledStepIndexList = new int[seqLength];        int[] shuffledVariantIndexList = new int[seqLength];        int[] shuffledStepIndexListNumStepsOnly = new int[numSteps];        int[] shuffledVariantIndexListNumStepsOnly = new int[numSteps];        List<SeqVariant> cloneSourceList = new List<SeqVariant>(sequence);        for (int i = 0; i < seqLength; i++)        {            cloneSourceList[i] = new SeqVariant(sequence[i]);        }        //-- First do the entire list, so that if the user increases numSteps, they are still good entries        shuffledVariantIndexList = GetShuffledIndexArray(seqLength, numVariants, layer);        shuffledStepIndexList = GetShuffledIndexArray(seqLength, numSteps, layer);        for (int i = 0; i < seqLength; i++)        {            int shuffledStepIndex = i;            if (shuffleStepSettingsAlso == true)                shuffledStepIndex = shuffledStepIndexList[i];            int shuffledVariantIndex = shuffledVariantIndexList[i];            sequence[i] = cloneSourceList[shuffledStepIndex];            sequence[i].objIndex = shuffledVariantIndex;            sequence[i].go = variantsList[shuffledVariantIndex].go;        }        //-- Now do it just for the numSteps, if it's small, the above list might be clumped and not have a fair mix         //-- for the first numSteps        shuffledVariantIndexListNumStepsOnly = GetShuffledIndexArray(numSteps, numVariants, layer);        shuffledStepIndexListNumStepsOnly = GetShuffledIndexArray(numSteps, numSteps, layer);        for (int i = 0; i < numSteps; i++)        {            int stepIndex = i;            if (shuffleStepSettingsAlso == true)                stepIndex = shuffledStepIndexListNumStepsOnly[i];            int variantIndex = shuffledVariantIndexListNumStepsOnly[i];            sequence[i] = cloneSourceList[stepIndex];            sequence[i].objIndex = variantIndex;            sequence[i].go = variantsList[variantIndex].go;        }    }    //------------------------------------------------    public static void AssignObjectIndicesInSequence(List<SeqVariant> sequence,  int numSteps, List<FenceVariant> variantsList)    {            int numVariants = variantsList.Count;            int seqLength = sequence.Count;            int[] sequentialIndexList = new int[seqLength];            int variantIndex = 0;            for (int i = 0; i < seqLength; i++)            {                sequentialIndexList[i] = variantIndex++;                if (variantIndex == numVariants)                    variantIndex = 0;            }        // Loop them to fill entire sequence, even if we're only using a few steps            int stepsLoop = 0;            for (int i = 0; i < numSteps; i++)            {                sequence[i].objIndex = sequentialIndexList[stepsLoop++];                if (stepsLoop == numSteps)                    stepsLoop = 0;                sequence[i].go = variantsList[sequence[i].objIndex].go;            }    }}//------------------------------------------------//- Holds details about a fixed number (kNumRailVariations) of  source objects used in Variations[System.Serializable]public class FenceVariant{    public GameObject go = null;    public string goName = "";//ONLY used when saving/loading variants in a scriptable obj preset after removing the prefab. Never assume it's vaild otherwise    public Vector3 positionOffset = Vector3.zero;    public Vector3 size = Vector3.one; // multiplies with the main rail size    public Vector3 rotation = Vector3.zero;     public bool    enabled = false;    public float   probability = 1;    public float   invert, backToFront, mirrorZ;    public int     singleIndex = -1; //Onlu used whn keeping lists of singles        // Basic Constructor    public FenceVariant()    {        go = null;        goName = "";        positionOffset = Vector3.zero;        size = Vector3.one;        rotation = Vector3.zero;        enabled = false;        probability = 0.5f;        invert = 0;        backToFront = 0;        mirrorZ = 0;    }    // if copyGo = true we Instantiate a new clone copy of the go, otherwise we just copy its name and set go = null. Useful when saving presets.    // You only need to pass in 'AutoFenceCreator af' if you want it to locate the prefab by name instead (required when loading presets)    public FenceVariant(FenceVariant inVar, bool copyGo, AutoFenceCreator.FencePrefabType prefabType = 0, AutoFenceCreator af = null)    {        if (copyGo == true)        {            if(inVar.go != null)                go = GameObject.Instantiate(inVar.go);            else if(inVar.go == null && inVar.goName != "" && af != null)            {                goName = inVar.goName;//in case the Find fails                go = af.FindPrefabByName(prefabType, inVar.goName);                if (go != null)                    goName = go.name;            }        }        else if (copyGo == false){             go = null;            if (inVar.go != null)                goName = inVar.go.name;        }        positionOffset = inVar.positionOffset;        size = inVar.size;        rotation = inVar.rotation;        enabled = inVar.enabled;        probability = inVar.probability;        invert = inVar.invert;        backToFront = inVar.backToFront;        mirrorZ = inVar.mirrorZ;    }    public FenceVariant(GameObject inGO)    {        Initialize();        go = inGO;        goName = inGO.name;    }    public FenceVariant(string inGOName)    {        Initialize();        goName = inGOName;    }   // Constructor for when linking to singles   /*public FenceVariant(int inSingleIndex)    {        Initialize();        singleIndex = inSingleIndex;    }*/    public void Initialize()    {        go = null;        goName = "";        positionOffset = Vector3.zero;        size = Vector3.one;        rotation = Vector3.zero;        enabled = false;        probability = 0.5f;        invert = 0;        backToFront = 0;        mirrorZ = 0;    }     //-----------------------    public static void AddVariantToSingles(AutoFenceCreator.LayerSet layerSet, int inSingleSectionIndex, int variantListIndex, AutoFenceCreator af)    {        FenceVariant variant = null;        List<FenceVariant> variantList = null, singleVariantsList = null;        if (layerSet == AutoFenceCreator.LayerSet.railALayerSet)        {            variantList = af.railAVariants;            singleVariantsList = af.railASingleVariants;        }        if (layerSet == AutoFenceCreator.LayerSet.railBLayerSet)        {            variantList = af.railBVariants;            singleVariantsList = af.railBSingleVariants;        }        bool refForSingleIndexExists = false;        // Check if an entry already exists, if not create one        foreach (FenceVariant thisVariant in singleVariantsList)        {            if (thisVariant.singleIndex == inSingleSectionIndex)            {                refForSingleIndexExists = true;                variant = thisVariant;                variant.go = variantList[variantListIndex].go;                break;            }        }        if (refForSingleIndexExists == false)        {            variant = new FenceVariant();            variant.singleIndex = inSingleSectionIndex;            variant.go = variantList[variantListIndex].go;            variant.enabled = true;            singleVariantsList.Add(variant);        }    }    //-----------------------    public static FenceVariant[] CreateFenceVariantArray(int size)    {        FenceVariant[] array = new FenceVariant[size];        for(int i=0; i<size; i++)        {            array[i] = new FenceVariant();        }        return array;    }    public static List<FenceVariant> CreateInitialisedFenceVariantList(int size = 0)    {        if (size == 0)            size = AutoFenceCreator.kNumRailVariations;        FenceVariant[] newVariants = CreateFenceVariantArray(size);        List<FenceVariant> variantList = new List<FenceVariant>(newVariants);        return variantList;    }}//--------------------------------------------------//      Static functions for FenceVariants//--------------------------------------------------public class FenceVariations{    public int numObjects = 1, numFlips = 1;    public static List<GameObject> GetAllGameObjectsFromVariations(List<FenceVariant> variants)    {        List<GameObject> goList = new List<GameObject>();        int count = variants.Count;        for(int i=0; i<count; i++)        {            goList.Add(variants[i].go);        }        return goList;    }    //------------------------------------------------    // Creates a list of variants with the correct proportion of each type, based on their probabiity.    public static int[] CreateShuffledIndices(List<FenceVariant> variants, int numFenceSections)    {        float totalProb = 0, proportion = 0;        int numVariants = variants.Count;        int numOfThisType = 0, indexCount=0;        int[] shuffledIndexList = new int[numFenceSections];                for(int i=0; i<variants.Count; i++)        {            totalProb += variants[i].probability;        }        // make a list with the correct proportion        for(int i=0; i<numVariants; i++)        {            if (indexCount == numFenceSections)                break;            proportion = variants[i].probability/totalProb;            numOfThisType = (int)((proportion * numFenceSections)+0.5f);            for(int j=0; j<numOfThisType; j++)            {                shuffledIndexList[indexCount++] =  i;                if(indexCount == numFenceSections)                    break;            }        }        // Now shuffle them        for(int i=0; i<numFenceSections; i++)        {            int j = UnityEngine.Random.Range(i, numFenceSections); //numFenceSections is exclusive because  Random.Range(int, int)            int t = shuffledIndexList[j];            shuffledIndexList[j] = shuffledIndexList[i];            shuffledIndexList[i] = t;        }        return shuffledIndexList;     }    //--------------------------------------------------    // Create Optimally different series of orientations, then repeat once more, slightly different    // all sequences are initialized to false, some are restated for clarity    public static List<SeqVariant> CreateOptimalSequence(List<FenceVariant> objects, bool backToFront, bool mirrorZ, bool invertZ)    {        List<SeqVariant> seq = new List<SeqVariant>();        //--------------------------        int numObjects = objects.Count, variantIndex = 0; ;        int numOrients = 0, numVariants = 0, numVariantsDoubled = 0;        // No Orientation Changes        if (backToFront == false && mirrorZ == false && invertZ == false)        {            numOrients = 0;            numVariants = numObjects;            SeqVariant[] x = new SeqVariant[numVariants];            for (int p = 0; p < numVariants; p++)            {                variantIndex = p % numObjects;                x[p] = new SeqVariant(variantIndex, objects[variantIndex]); // initialize with objectIndex                seq.Add(x[p]); //Set the object index to cycle around the number available            }        }        // backToFront only        if (backToFront == true && mirrorZ == false && invertZ == false)        {            numOrients = 2;            if (numObjects == 1)            {                numVariants = numOrients * numObjects;                SeqVariant[] x = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    x[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                x[0].backToFront = false;                x[1].backToFront = true;                seq = new List<SeqVariant>(x);            }            if (numObjects > 1)            {                numVariants = numOrients * numObjects * 2;                SeqVariant[] x = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    x[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                x[0].backToFront = false;                x[1].backToFront = true;                x[2].backToFront = true;                x[3].backToFront = false;                                x[4].backToFront = true;                x[5].backToFront = false;                x[6].backToFront = false;                x[7].backToFront = true;                seq = new List<SeqVariant>(x);            }        }        // mirrorZ only        if(backToFront == false && mirrorZ == true && invertZ == false)        {            numOrients = 2;            if (numObjects >= 1)            {                numVariants = numOrients * numObjects;                SeqVariant[] z = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                z[0].mirrorZ = false;                z[1].mirrorZ = true;                seq = new List<SeqVariant>(z);            }            if (numObjects > 1)            {                numVariants = numOrients * numObjects * 2;                SeqVariant[] z = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                z[0].mirrorZ = false;                z[1].mirrorZ = true;                z[2].mirrorZ = true;                z[3].mirrorZ = false;                                z[4].mirrorZ = true;                z[5].mirrorZ = false;                z[6].mirrorZ = false;                z[7].mirrorZ = true;                seq = new List<SeqVariant>(z);            }        }        // invertZ        if(backToFront == false && mirrorZ == false && invertZ == true)        {            numOrients = 2;            if (numObjects == 1)            {                numVariants = numOrients * numObjects;                SeqVariant[] invert_z = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    invert_z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                invert_z[0].invert = false;                invert_z[1].invert = true;                seq = new List<SeqVariant>(invert_z);            }            if (numObjects > 1)            {                numVariants = numOrients * numObjects * 2;                SeqVariant[] invert_z = new SeqVariant[numVariants];                for (int p = 0; p < numVariants; p++){                    variantIndex = p % numObjects;                    invert_z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                invert_z[0].invert = false;                invert_z[1].invert = true;                invert_z[2].invert = true;                invert_z[3].invert = false;                                invert_z[4].invert = false;                invert_z[5].invert = true;                invert_z[6].invert = true;                invert_z[7].invert = false;                seq = new List<SeqVariant>(invert_z);            }        }                // backToFront mirrorZ        if(backToFront == true && mirrorZ == true && invertZ == false)        {            numOrients = 4;            if (numObjects >= 1)            {                numVariants = numOrients * numObjects;                numVariantsDoubled = numVariants * 2;                SeqVariant[] x_z = new SeqVariant[numVariantsDoubled];                for (int p = 0; p < numVariantsDoubled; p++){                    variantIndex = p % numObjects;                    x_z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                x_z[0].backToFront = false;                x_z[0].mirrorZ = false;                                x_z[1].backToFront = true;                                x_z[2].mirrorZ = true;                                x_z[3].backToFront = true;                x_z[3].mirrorZ = true;                //----------------------                x_z[4].backToFront = true;                                x_z[5].backToFront = false;                x_z[5].mirrorZ = false;                                x_z[6].backToFront = true;                x_z[6].mirrorZ = true;                                x_z[7].mirrorZ = true;                                // Repeat Backwards                for(int i=numVariants; i<numVariantsDoubled; i++)                {                    int indexToCopy = i % numVariants;                    //indexToCopy /= 2;                                        indexToCopy = ((numVariants -1) - indexToCopy) + 1;                    if(indexToCopy == numVariantsDoubled )                        indexToCopy = numVariants-1;                    x_z[i] = x_z[indexToCopy];                                    }                                seq = new List<SeqVariant>(x_z);            }        }        // backToFront invertX        if(backToFront == true && mirrorZ == false && invertZ == true)        {            numOrients = 4;            if (numObjects >= 1)            {                numVariants = numOrients * numObjects;                numVariantsDoubled = numVariants * 2;                SeqVariant[] x_invert = new SeqVariant[numVariantsDoubled];                for (int p = 0; p < numVariantsDoubled; p++){                    variantIndex = p % numObjects;                    x_invert[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                x_invert[0].backToFront = false;                x_invert[0].invert = false;                                x_invert[1].backToFront = true;                                x_invert[2].invert = true;                                x_invert[3].backToFront = true;                x_invert[3].invert = true;                //----------------------                x_invert[4].backToFront = true;                                x_invert[5].backToFront = false;                x_invert[5].invert = false;                                x_invert[6].backToFront = true;                x_invert[6].invert = true;                                x_invert[7].invert = true;                                // Repeat Backwards                for(int i=numVariants; i<numVariantsDoubled; i++)                {                    int indexToCopy = i % numVariants;                    //indexToCopy /= 2;                                        indexToCopy = ((numVariants -1) - indexToCopy) + 1;                    if(indexToCopy == numVariantsDoubled )                        indexToCopy = numVariants-1;                    x_invert[i] = x_invert[indexToCopy];                                    }                seq = new List<SeqVariant>(x_invert);            }        }        // mirrorZ invertX        if(backToFront == false && mirrorZ == true && invertZ == true)        {            numOrients = 4;            if (numObjects >= 1)            {                numVariants = numOrients * numObjects;                numVariantsDoubled = numVariants * 2;                SeqVariant[] z_invert = new SeqVariant[numVariantsDoubled];                for (int p = 0; p < numVariantsDoubled; p++){                    variantIndex = p % numObjects;                    z_invert[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                z_invert[0].mirrorZ = false;                z_invert[0].invert = false;                                z_invert[1].mirrorZ = true;                                z_invert[2].invert = true;                                z_invert[3].mirrorZ = true;                z_invert[3].invert = true;                //----------------------                z_invert[4].mirrorZ = true;                                z_invert[5].mirrorZ = false;                z_invert[5].invert = false;                                z_invert[6].mirrorZ = true;                z_invert[6].invert = true;                                z_invert[7].invert = true;                                // Repeat Backwards                for(int i=numVariants; i<numVariantsDoubled; i++)                {                    int indexToCopy = i % numVariants;                                        indexToCopy = ((numVariants -1) - indexToCopy) + 1;                    if(indexToCopy == numVariantsDoubled )                        indexToCopy = numVariants-1;                    z_invert[i] = z_invert[indexToCopy];                                    }                                seq = new List<SeqVariant>(z_invert);            }        }                // backToFront  mirrorZ  invertZ        if(backToFront == true && mirrorZ == true && invertZ == true)        {            numOrients = 8;            if (numObjects >= 1)            {                numVariants = numOrients * numObjects;                numVariantsDoubled = numVariants * 2;                SeqVariant[] invert_x_z = new SeqVariant[numVariantsDoubled];                for (int p = 0; p < numVariantsDoubled; p++){                    variantIndex = p % numObjects;                    invert_x_z[p] = new SeqVariant(variantIndex, objects[variantIndex]);                 }                invert_x_z[1].backToFront = true;                                invert_x_z[2].mirrorZ = true;                                invert_x_z[3].invert = true;                    invert_x_z[4].invert = true;                invert_x_z[4].backToFront = true;                    invert_x_z[5].backToFront = true;                invert_x_z[5].mirrorZ = true;                    invert_x_z[6].invert = true;                invert_x_z[6].mirrorZ = true;                    invert_x_z[7].invert = true;                invert_x_z[7].mirrorZ = true;                invert_x_z[7].backToFront = true;                                    invert_x_z[8].invert = true;                invert_x_z[9].mirrorZ = true;                invert_x_z[10].backToFront = true;                                invert_x_z[11].invert = true;                invert_x_z[11].backToFront = true;                    invert_x_z[12].backToFront = false;                invert_x_z[12].mirrorZ = false;                invert_x_z[12].mirrorZ = false;                                invert_x_z[13].backToFront = true;                invert_x_z[13].mirrorZ = true;                    invert_x_z[14].invert = true;                invert_x_z[14].mirrorZ = true;                invert_x_z[14].backToFront = true;                                invert_x_z[15].invert = true;                invert_x_z[15].mirrorZ = true;                // Repeat Backwards                for (int i = numVariants; i < numVariantsDoubled; i++)                {                    int indexToCopy = i % numVariants;                    indexToCopy = ((numVariants - 1) - indexToCopy) + 1;                    if (indexToCopy == numVariantsDoubled)                        indexToCopy = numVariants - 1;                    invert_x_z[i] = invert_x_z[indexToCopy];                }                seq = new List<SeqVariant>(invert_x_z);            }        }        //Debug.Log("numObjects = " + numObjects + "        numOrients = " + numOrients + "        numVariants = " + numVariants);        return seq;    }    //------------    public static void PrintFenceVariantList(List<FenceVariant> variantList)    {        int length = variantList.Count;        Debug.Log("------------\n");        for (int i = 0; i < length; i++)        {            Debug.Log(variantList[i].go.name + "\n");        }    }    //---------    public static void PrintSeqVariantList(List<SeqVariant> variantList, int n = 0)    {        int length = variantList.Count;        if (n > 0)            length = n;        Debug.Log("------------\n");        for (int i = 0; i < length; i++)        {            Debug.Log(variantList[i].objIndex + ": " + variantList[i].go.name + "\n");        }    }}